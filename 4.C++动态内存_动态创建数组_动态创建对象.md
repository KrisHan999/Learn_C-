**静态存储分配**：通常定义变量（或对象），编译器在**编译时**都可以根据该变量（或对象）的类型知道所需内存空间的大小，从而系统在适当的时候为他们**分配确定的存储空间**。这种内存分配称为静态存储分配；

**动态存储分配**：有些操作对象只在**程序运行时才能确定**，这样编译时就**无法**为他们**预定存储空间**，只能在程序运行时，系统根据运行时的要求进行内存分配，这种方法称为动态存储分配。**所有动态存储分配都在堆区中进行**。

## 1.堆空间申请、释放演示：

**堆空间申请、释放**的方法：

在C++中，申请和释放堆中分配的存贮空间，分别使用**new**和**delete**的两个运算符来完成

```cpp
指针变量名=new 类型名(初始化式)；
delete 指针名;

int *pi=new int(0);
//等价int ival=0, *pi=&ival;
```

**堆区**是**不会**在分配时做**自动初始化**的（包括清零），所以**必须用初始化式(initializer)来显式初始化**。new表达式的操作序列如下：从堆区分配对象，然后用括号中的值初始化该对象。

⑴.用初始化式(initializer)来显式初始化

```cpp
int *pi=new int(0);
```

⑵.当pi生命周期结束时，必须释放pi所指向的目标，指针仍然存在，最好将**指针指向nullptr**：

```cpp
delete pi;
pi = nullptr;
//注意释放内存空间后，指针仍然存在，最好将指针指向nullptr
```

## 2.在堆中建立动态一维数组

①申请数组空间：

指针变量名=new 类型名\[下标表达式];

注意：“下标表达式”不是常量表达式，即**它的值不必在编译时确定，可以在运行时确定**。

②释放数组空间：

delete \[ ]指向该数组的指针变量名;

**没有初始化式（initializer），不可对数组初始化。**

```cpp
#include <iostream>
#include <string>
#include <cstring>
using namespace std;
int main() {
    int n;
    cin >> n;
    char * ptr = new char [n];
    strcpy(ptr, "hello");
    cout << ptr << endl;
    delete []ptr;
    ptr = nullptr;

    return 0;
}
```

## 3.在堆中建立动态二维数组

```cpp
//动态创建二维数组
int (*b2)[10]=new int[6][10]; \\注意，这里的b2指向了一个二维int型数组的首地址.
//动态删除二维数组，和一维数组一样
delete [] b2;  //删除（释放）二维数组；
//具体某一个元素
//*(*(p+i)+j)-> p[i][j]
```

另一种方法创建二维数组，比较复杂

```cpp
#include <iostream>
using namespace std;

int main()
{

    int i,j;   //p[4][8] 
    //开始分配4行8列的二维数据
    int **p = new int *[4];            //二级指针指向一级指针数组
                                       //这句可以换成int *p[4]; 
                                       //最后就不需要delete [] p，而只delete [] p[i];

    for(i=0;i<4;i++){
        p[i]=new int [8];        //每一个一级指针指向一个数组

    }

    for(i=0; i<4; i++){
        for(j=0; j<8; j++){
            p[i][j] = j*i;
        }
    }   
    //打印数据   
    for(i=0; i<4; i++){
        for(j=0; j<8; j++)     
        {   
            if(j==0) cout<<endl;   
            cout<<p[i][j]<<"\t";   
        }
    }   
    //开始释放申请的堆   
    for(i=0; i<4; i++){
        delete [] p[i];   
    }
    delete [] p;   
    return 0;
}
```

## 4.指针数组和数组指针

指针类型:

(1)int*ptr;//指针所指向的类型是int  
(2)char*ptr;//指针所指向的的类型是char  
(3)int\*\*ptr;//指针所指向的的类型是int* （也就是一个int * 型指针）  
(4)int(*ptr)\[3];//指针所指向的的类型是int()\[3] //二维指针的声明

指针数组：  
一个数组里存放的都是同一个类型的指针，通常我们把他叫做指针数组。

比如 int * a\[2];它里边放了2个int * 型变量 .

```c
int * a[2];
a[0]= new int[3];
a[1]=new int[3];
delete [] a[0];
delete [] a[1];
```

## 5.动态创建对象

**使用类名定义的对象都是静态的**，在程序运行过程中，对象所占的空间是不能随时释放的。但有时人们希望在需要用到对象时才建立对象，在不需要用该对象时就撤销它，释放它所占的内存空间以供别的数据使用。这样可提高内存空间的利用率。**C++中，可以用new运算符动态建立对象，用delete运算符撤销对象**

比如： 

Box *pt;  //定义一个指向Box类对象的指针变量pt

pt=new Box;  //在pt中存放了新建对象的起始地址

在程序中就可以通过pt访问这个新建的对象。如

cout<\< pt->height;  //输出该对象的height成员

cout<\< pt->volume( );  //调用该对象的volume函数，计算并输出体积

C++还允许在执行new时，对新建立的对象进行初始化。如  

Box *pt=new Box(12,15,18);  

这种写法是把上面两个语句(定义指针变量和用new建立新对象)合并为一个语句，并指定初值。这样更精炼。  

新对象中的height，width和length分别获得初值12,15,18。**调用对象既可以通过对象名，也可以通过指针。**  

在执行new运算时，如果内存量不足，无法开辟所需的内存空间，目前大多数C++编译系统都使new返回一个0指针值。只要检测返回值是否为0，就可判断分配内存是否成功。  

ANSI C++标准提出，在执行new出现故障时，就“抛出”一个“异常”，用户可根据异常进行有关处理。但C++标准仍然允许在出现new故障时返回0指针值。当前，不同的编译系统对new故障的处理方法是不同的。  

在不再需要使用由new建立的对象时，可以用delete运算符予以释放。如  

**delete pt; //释放pt指向的内存空间  **

**这就撤销了pt指向的对象。此后程序不能再使用该对象。**  

如果用一个指针变量pt先后指向不同的动态对象，应注意指针变量的当前指向，以免删错了对象。在执行delete运算符时，在释放内存空间之前，自动调用析构函数，完成有关善后清理工作。
