1. **const类型对象可以访问const类型成员函数，但是不可以访问非const类型成员函数。**

2. **const成员函数内可以调用其它的const成员函数，但是const成员函数不可以调用非const成员函数。**

3. **非const成员函数内既可以调用其它的const成员函数，也可以调用非const成员函数。**

4. 整型**static const/const static**数据成员(static const int)，可以**在类内声明的时候进行初始化**

在一个对象**调用构造函数**时，会**隐含一个新参this指针**。

> 也就是说，当我们定义了一个类(A)的非const类型的成员函数为**A::Fun()**。
> 实际上在编译器中该函数的定义是**A::Fun(A* const this)**，**该this指向的内容可以改变，但是this指针不能被改变**。当我们用A的一个对象a调用Fun函数，**a.Fun()**，编译器会将其解释为**Fun(&a)**，所以在Fun中使用this指针就可以改变对象a的成员变量了。

当对象是const类型的，即**const A a**;那么是什么意思呢？

> 表示的是a的内容不可以改变，当我们把&a作为参数传到形参this时，就出现了矛盾。a是一个变量，其成员不可以改变。this指针的成员变量是可以改变的。如果我们将a的地址传给this，那么a这个变量的值也就可以在this中改变了，所以，编译器是不允许出现这种矛盾的，就会给我们提示错误消息。

**所以，const类型对象是不可以访问非const类型成员函数。**

> 那么，当**成员函数是const类型**时，**A::Fun() const**，在编译器解释时会将函数解释为 **A::Test(const A* const this)**; **this指针及其所指向的内容都不可被修改**，也就不会存在前面说的矛盾了。

**所以，const对象可以访问const类型的成员函数。**
