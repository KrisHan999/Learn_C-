## 1.C++多态



**当基类指针指向子类对象，基类指针只能调用子类中继承基类的方法或者实现多态的方法。**



**多态**按字面的意思就是多种形态。当**类之间存在层次结构**，并且类之间是**通过继承关联**时，就会**用到多态**。

C++ 多态意味着**调用成员函数时**，会根据**调用函数的对象的类型来执行不同的函数**。

**C++的多态性用一句话概括**就是：在**基类的函数前加上virtual关键字**，**在派生类中重写该函数**，运行时将会**根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数

  1：**用virtual关键字申明的函数叫做虚函数**，虚函数肯定是类的成员函数。  

  2：存在虚函数的类都有一个一维的虚函数表叫做**虚表**，类的对象有一个指向虚表开始的虚指针。虚表是和类对应的，虚表指针是和对象对应的。  

  3：**多态性是一个接口多种实现**，是面向对象的核心，分为类的多态性和函数的多态性。  

  4：**多态用虚函数来实现，结合动态绑定**.

  5:   **纯虚函数是虚函数再加上 = 0;**

  6：**抽象类是指包括至少一个纯虚函数的类。**

  7：**基类指针指向子类对象，如果实现多态，仍然执行的是子类重载的成员函数，子类有的而父类没有的函数或成员，基类指针不能访问；**

**虚函数的定义要遵循以下重要规则：**   

1.如果虚函数在基类与派生类中出现，仅仅是名字相同，而形式参数不同，或者是返回类型不同，那么即使加上了virtual关键字，也是不会进行滞后联编的。   

2.**只有类的成员函数才能说明为虚函数**，因为虚函数仅适合用与有继承关系的类对象，所以普通函数不能说明为虚函数。   

3.**静态成员函数不能是虚函数,因为静态成员函数的特点是不受限制于某个对象**。   

4.**内联(inline)函数不能是虚函数**，因为内联函数不能在运行中动态确定位置。即使虚函数在类的内部定义定义，但是在编译的时候系统仍然将它看做是非内联的。   

5.**构造函数不能是虚函数，因为构造的时候**，对象还是一片位定型的空间，只有构造完成后，对象才是具体类的实例。   

6.**析构函数可以是虚函数,而且通常声名为虚函数。**

**同时需要了解多态的特性的virtual修饰，不单单对基类和派生类的普通成员 函数有必要，而且对于基类和派生类的析构函数同样重要！！！**

7.当**基类指针指向子类对象时**，如果**基类的析构函数不是virtual**，那么子类的析构函数将不会被调用，子类的资源没有正确是释放，因此造成内存泄露

```cpp
#include <iostream> 
using namespace std;

class Shape {
   protected:
      int width, height;
   public:
      Shape( int a=0, int b=0)
      {
         width = a;
         height = b;
      }
      int area()
      {
         cout << "Parent class area :" <<endl;
         return 0;
      }
};
class Rectangle: public Shape{
   public:
      Rectangle( int a=0, int b=0):Shape(a, b) { }
      int area ()
      { 
         cout << "Rectangle class area :" <<endl;
         return (width * height); 
      }
};
class Triangle: public Shape{
   public:
      Triangle( int a=0, int b=0):Shape(a, b) { }
      int area ()
      { 
         cout << "Triangle class area :" <<endl;
         return (width * height / 2); 
      }
};
// 程序的主函数
int main( )
{
   Shape *shape;
   Rectangle rec(10,7);
   Triangle  tri(10,5);

   // 存储矩形的地址
   shape = &rec;                        //基类指针指向子类对象

   // 调用矩形的求面积函数 area
   shape->area();                        //因为基类函数不是虚函数，所以基类指针还是指向子类对象中的基类函数

   // 存储三角形的地址
   shape = &tri;
   // 调用三角形的求面积函数 area
   shape->area();                        //因为基类函数不是虚函数，所以基类指针还是指向子类对象中的基类函数

   return 0;
}
```

当上面的代码被编译和执行时，它会产生下列结果：

```cpp
Parent class area
Parent class area
```

导致错误输出的原因是，**调用函数 area() 被编译器设置为基类中的版本**，这就是所谓的**静态多态**，或**静态链接**- 函数调用在程序执行前就准备好了。有时候这也被称为**早绑定**，因为 area() 函数在程序编译期间就已经设置好了。

但现在，让我们对程序稍作修改，在 Shape 类中，area() 的声明前放置关键字**virtual**，如下所示：

```cpp
class Shape {
   protected:
      int width, height;
   public:
      Shape( int a=0, int b=0)
      {
         width = a;
         height = b;
      }
      virtual int area()
      {
         cout << "Parent class area :" <<endl;
         return 0;
      }
};
```

修改后，当编译和执行前面的实例代码时，它会产生以下结果：

```cpp
Rectangle class area
Triangle class area
```

此时，**编译器看的是指针的内容**，**而不是它的类型**。因此，**由于 tri 和 rec 类的对象的地址存储在 *shape 中，所以会调用各自的 area() 函数**。

正如您所看到的，每个**子类都有一个函数 area() 的独立实现**。这就是**多态**的一般使用方式。有了多态，您可以有多个不同的类，都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的。

## 2.虚函数

**虚函数**是在基类中使用关键字**virtual**声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉**编译器不要静态链接到该虚函数**。

我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为**动态链接**，或**后期绑定**。

## 3.纯虚函数

您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。

我们可以把基类中的虚函数 area() 改写如下：

```cpp
class Shape {
   protected:
      int width, height;
   public:
      Shape( int a=0, int b=0)
      {
         width = a;
         height = b;
      }
      // pure virtual function
      virtual int area() = 0;
};
```

= 0 告诉编译器，函数没有主体，上面的虚函数是**纯虚函数**。
