## C++对象内存分配问题

如果一个人自称为程序高手，却对内存一无所知，那么我可以告诉你，他一定在吹牛。用C或C++写程序，需要更多地关注内存，这不仅仅是因为内存的分配是否合理直接影响着程序的效率和性能，更为主要的是，当我们操作内存的时候一不小心就会出现问题，而且很多时候，这些问题都是不易发觉的，比如内存泄漏，比如悬挂指针。笔者今天在这里并不是要讨论如何避免这些问题，而是想从另外一个角度来认识C++内存对象。   

　　我们知道，C++将内存划分为三个逻辑区域：**堆、栈和静态存储区**。既然如此，我称位于它们之中的对象分别为**堆对象，栈对象以及静态对象**。那么这些不同的内存对象有什么区别了？堆对象和栈对象各有什么优劣了？如何禁止创建堆对象或栈对象了？这些便是今天的主题。   

　　**一．基本概念**  

　　先来看看栈。栈，一般用于存放局部变量或对象，如我们在函数定义中用类似下面语句**声明的对象**：  

        `Type stack_object ;`

　　**stack_object便是一个栈对象**，它的生命期是从定义点开始，当所在函数返回时，生命结束。  

　　另外，几乎所有的临时对象都是栈对象。比如，下面的**函数定义**：  

        `Type fun(Type object) ;`

　　这个函数**至少产生两个临时对象**，首先，参数是**按值传递**的，所以会调用**拷贝构造函数生成一个临时对象**object_copy1 ，在**函数内部使用的**不是使用的不是object，而**是object_copy1**，自然，**object_copy1是一个栈对象，它在函数返回时被释放**；还有这个函数是**值返回的**，在函数返回时，如果我们不考虑返回值优化（NRV），那么也**会产生一个临时对象object_copy2**，这个**临时对象会在函数返回后一段时间内被释放**。比如某个函数中有如下代码：  

```
Type tt ,result ; //生成两个栈对象 
tt = fun(tt) ; //函数返回时，生成的是一个临时对象object_copy2
```

　　上面的第二个语句的执行情况是这样的，首先函数**fun返回时生成一个临时对象object_copy2** ，然后再调用赋值运算符执行  

        `tt = object_copy2 ; //调用赋值运算符`

　　看到了吗？编译器在我们毫无知觉的情况下，为我们生成了这么多临时对象，而生成这些临时对象的时间和空间的开销可能是很大的，所以，你也许明白了，为什么**对于“大”对象最好用const引用传递代替按值进行函数参数传递了**。  

　　接下来，看看堆。**堆**，又叫自由存储区，它是在程序执行的过程中**动态分配的**，所以它最大的特性就是动态性。在C++中，所有堆对象的创建和销毁都要由程序员负责，所以，如果处理不好，就会发生内存问题。如果分配了堆对象，却忘记了释放，就会产生**内存泄漏**；而如果已释放了对象，却没有将相应的指针置为NULL，该指针就是所谓的**“悬挂指针”**，再度使用此指针时，就会出现非法访问，严重时就导致程序崩溃。  

　　那么，**C++中是怎样分配堆对象的？唯一的方法就是用new**（当然，用类malloc指令也可获得C式堆内存），只要使用new，就会在堆中分配一块内存，并且返回指向该堆对象的指针。  

　　再来看看**静态存储区**。所有的静态对象、全局对象都于静态存储区分配。关于全局对象，是在main()函数执行前就分配好了的。其实，**在main()函数中的显示代码执行之前，会调用一个由编译器生成的_main()函数，而_main()函数会进行所有全局对象的的构造及初始化工作。而在main()函数结束之前，会调用由编译器生成的exit函数，来释放所有的全局对象。**比如下面的代码：  

```
void main（void）
{
　… …// 显式代码
}
```

        实际上，被转化成这样：

```
void main（void）
{
　_main（）; //隐式代码，由编译器产生，用以构造所有全局对象
　… … // 显式代码
　… …
　exit（） ; // 隐式代码，由编译器产生，用以释放所有全局对象
}
```

        还有一种**静态对象**，那就是它作为class的静态成员。考虑这种情况时，就牵涉了一些较复杂的问题。

　　第一个问题是c**lass的静态成员对象的生命期**，**class的静态成员对象随着第一个class object的产生而产生**，在整个程序结束时消亡。也就是有这样的情况存在，在程序中我们定义了一个class，该类中有一个静态对象作为成员，但是在程序执行过程中，**如果我们没有创建任何一个该class object，那么也就不会产生该class所包含的那个静态对象**。还有，如果创建了多个class object，那么所有这些object都共享那个静态对象成员。  

　　第二个问题是，当出现下列情况时：  

```
class Base
{
　public:
　　static Type s_object ;
}
class Derived1 : public Base / / 公共继承
{
　… …// other data 
}
class Derived2 : public Base / / 公共继承
{
　… …// other data 
}

Base example ;
Derivde1 example1 ;
Derivde2 example2 ;
example.s_object = …… ;
example1.s_object = …… ; 
example2.s_object = …… ;
```

　　请注意上面标为黑体的三条语句，**它们所访问的s_object是同一个对象吗？答案是肯定的**，它们的确是指向同一个对象，这听起来不像是真的，是吗？但这是事实，你可以自己写段简单的代码验证一下。我要做的是来解释为什么会这样？ 我们知道，当一个类比如Derived1，从另一个类比如Base**继承**时，那么，**可以看作一个Derived1对象中含有一个Base型的对象，这就是一个subobject**。一个Derived1对象的大致内存布局如下：  

　　让我们想想，当我们将一个**Derived1型的对象传给一个接受非引用Base型参数的函数时会发生切割**，那么是怎么切割的呢？相信现在你已经知道了，那就是**仅仅取出了Derived1型的对象中的subobject**，而忽略了所有Derived1自定义的其它数据成员，然后将这个subobject传递给函数（实际上，函数中使用的是这个subobject的拷贝）。  

　　**所有继承Base类的派生类的对象都含有一个Base型的subobject**（这是能用Base型指针指向一个Derived1对象的关键所在，自然也是多态的关键了），**而所有的subobject和所有Base型的对象都共用同一个s_object对象**，自然，**从Base类派生的整个继承体系中的类的实例都会共用同一个s_object对象了**。
