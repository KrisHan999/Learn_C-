## C++引用

引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。

## C++ 引用 vs 指针

引用很容易与指针混淆，它们之间有三个主要的不同：

- **不存在空引用**。引用必须连接到一块合法的内存。
- 一旦引用被**初始化为一个对象**，**就不能被指向到另一个对象**。指针可以在任何时候指向到另一个对象。
- 引用必须**在创建时被初始化**。指针可以在任何时间被初始化。
- **声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。**
- **不能建立数组的引用。**因为数组是一个由若干个元素所组成的集合，所以无法建立一个数组的别名。

```cpp
int i = 17;
int & r = i;
r = 6;    //相当于i = 6;
```

### 1.引用作为参数

**调用函数时，形参(引用变量)指向实参变量单元。这种通过形参引用可以改变实参的值。**

- **传递引用**给函数与**传递指针**的**效果是一样**的。这时，被调函数的形参就成为原来主调函数中的实参变量或对象的一个别名来使用，所以在**被调函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作**。

- 使用**引用传递函数的参数**，**在内存中并没有产生实参的副本**，它是直接对实参操作；而使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配存储单元，形参变量是实参变量的副本；如果传递的是对象，还将调用拷贝构造函数。因此，当参数传递的数据较大时，用引用比用一般变量传递参数的效率和所占空间都好。

- 使用**指针**作为函数的参数虽然也能达到与使用引用的效果，但是，在**被调函数中同样要给形参分配存储单元**

```cpp
// 函数定义
void swap(int& x, int& y) //引用传递，实参也发生了变化
{
 int temp;
 temp = x; /* 保存地址 x 的值 */
 x = y; /* 把 y 赋值给 x */
 y = temp; /* 把 x 赋值给 y */
 return;
}
```

### 2.引用作为返回值

1. 以引用返回函数值，定义函数时需要**在函数名前加&**

2. 用引用返回一个函数值的最大好处是，在**内存中不产生被返回值的副本**。

3. **不能返回局部变量的引用**。主要原因是**局部变量会在函数返回后被销毁**，因此被返回的引用就成为了"无所指"的引用，程序会进入未知状态。

4. **不能返回函数内部new分配的内存的引用**。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成**memory leak。**

```cpp
#include <iostream>

using namespace std;

double vals[] = {10.1, 12.6, 33.1, 24.1, 50.0};


double& setValues( int i )
{
  return vals[i];   // 返回第 i 个元素的引用
}


// 要调用上面定义函数的主函数
int main ()
{

   cout << "改变前的值" << endl;
   for ( int i = 0; i < 5; i++ )
   {
       cout << "vals[" << i << "] = ";
       cout << vals[i] << endl;
   }

   setValues(1) = 20.23; // 改变第 2 个元素
   setValues(3) = 70.8;  // 改变第 4 个元素

   cout << "改变后的值" << endl;
   for ( int i = 0; i < 5; i++ )
   {
       cout << "vals[" << i << "] = ";
       cout << vals[i] << endl;
   }
   return 0;
}
```
